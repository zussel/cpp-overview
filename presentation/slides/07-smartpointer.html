<section>
    <section>
        <h2>Smarte Pointer</h2>
        <p>C++ hat keine eingebaute Garbage Collection. Jeder muss seinen
            M&uuml;ll selber wegr&auml;umen.</p>
        <p class="fragment">Ab c++11 werden aber clevere Helfer zur VerfÃ¼gung gestellt.</p>
    </section>
    <section>
        <p>Frage: Hast Du den Speicher auch wieder freigegeben?</p>
        <pre><code class="hljs" data-trim contenteditable>
void foo()
{
    int *i = new int;
    *i = 8;
}
        </code></pre>
        <p class="fragment">Antwort: Hab ich vergessen...</p>
    </section>
    <section>
        <p>L&ouml;sung ist <i>unique_ptr&lt;T&gt;</i></p>
        <pre><code class="hljs" data-trim contenteditable>
void foo()
{
    auto i = std::make_unique&lt;int&gt;(7);
    // mach was damit
    *i = 8;
}
        </code></pre>
    </section>
    <section>
        <p>Referenzz&auml;hler inklusive mit <i>shared_ptr</i></p>
        <pre><code class="hljs" data-trim contenteditable>
auto i1 = std::make_shared&lt;int&gt;(7);
std::cout &lt;&lt; "use count: " &lt;&lt; i1.use_count() &lt;&lt; "\n";

// $ use count: 1

auto i2 = i1;
std::cout &lt;&lt; "use count: " &lt;&lt; i1.use_count() &lt;&lt; "\n";

// $ use count: 2

i2.reset();
i1.reset();
// last reset destroys pointer
        </code></pre>
    </section>
    <section>
        <p>Was ist aber mit zyklischen shared_ptr Verweise?</p>
    </section>
</section>